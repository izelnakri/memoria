- TODO: I might want to make instances have .sortBy(), .mapBy() on array results
along with firstItem, lastItem/ extensions


- SQL Adapter tests
- Serializer interface
- push interface
- Consistent Error types and tests
- relationships
- Caching
- Maybe cache timeouts/intervals
- Check for instances(in all tests) and cache amounts in SQLAdapter

- MemoryAdapter should be able to handle string id/bigint columns for increment
- ORM should allow publickey and signatures as ids

make in build src adjust package.json main to dist or src based on clean or build script
- investigate relationship setting (!!)
- investigate error handling (!!)
- investigate changeset / repository / normal configuration
- investigate class-validator to ajv/JSON Schema exports (!!)
- investigate Adapter & Serializer interface




getters and instance method dont show on Object.keys etc Reflect.ownKeys



- investigate decorator validations
- maybe a more in-depth serializer

JS needs pipeline operator(|>) and cheap Rust bindings(JS<->Rust) and runtimes need to have ava API as default testing API(test.serial, test etc)

- investigate silent Errors within memoria.Server handler context
- make passthrough PASS
- add initializer.js
- memoria command shows options + loader + memoria browserify [dist] creates memoria.dist.js
- non-json request/responses? - just kidding... or do I?!?
- rollup -i ./lib/response.js -o response.js -f cjs
- memoria glue [jsonEndpoint]

// relationships declaration

import { cast, validateLength, validateRequired, foreignKeyConstraint } from 'memoria/changeset'; // instead use class-validator
import { from } from 'memoria/query';


// MODEL API:
import Model from 'memoria/model';

class User extends Model {
  Adapter: MemoryAdapter, // or SQLAdapter, JSONAPIAdapter, JSONAdapter, GraphQLAdapter
  Serializer: ModelSerializer // or JSONSerializer, JSONAPISerializer, GraphQLSerializer

  primaryKey = 'id' // or uuid or function(?)

  insert(options) {

  }
  update(options) {

  }
  delete(options) {

  }
  serializer(userOrUsers) {

  }
  serialize(user) {

  }
  resetDatabase(targetInitialState: object[]) {

  }

  // Model Query Interface:
  find(idOrIds) {

  }
  findBy(options) {

  }
  findAll(options) {

  }
  count(options) { // in memory, or in the resource through adapter with options?

  }

  // Extra examples: customAPIActions:
  confirm = APIAction({
    type: 'POST',
    before() {

    },
    after() {

    }
  })


  // private API: attributes, DB, defaultAttributes(string or lazy(with functions)) in future maybe as prop or decorator etc
  // maybe default App or DB validations expressed as decorators
}
Sketch:
User.insert({});

User { emails: hasManyProxy{}, firstName: 'Izel', lastName: 'Nakri' }

user.emails.then((emails) => {});

User.Adapter [sql, jsonapi, json, memory] , includes Repo reference, Repo setting at the beginning, synchronization strategies(later stage)
User.Serializer

User.findBy({}); => request

import { from, where, join, leftJoin, innerJoin } from 'memoria/query';

from()

Repo.one(query);
Repo.all(
