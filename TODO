Key to global optimization HistoryLog(a basis for CRDT), Datalog

-> Embedded relationships should be done seperatedly
model update
-> adapter update
-> adapter memory cache
-> RelationshipDB.cache
-> updateRelationshipsGloballyFromARelationship
-> complex lookup to set this.findRelationshipCacheFor(SourceClass, relationshipName, relationshipType).set(reference, targetModel);

4x(belongs-to-id, has-many-id) Memory, REST, SQLAdapter

// model.changeset -> this will have the metadata, but gets generated lazily
// model.changes -> this will have the actual changes and diffing from the previous source record
// model.revision -> this will have the previous source record(?) very error prone

// instanceMetadata
// So model.revision needs to change, get revision.builtAt, reason, and source, revision(needs to be previous model, test this always)

// Make params use match() internally: Email.findBy({ user: userInstance });

RelationshipUtils.replaceExistingModelFromArray() is not possible because replace first needs to remove it then add it in splice()
Because hasManyArray[someIndex] = aModel; doesnt remove items on its own but replace needs to remove the items in the setter level.
Anyways, more hasMany tracking is ok for now, logic should still work.

// never use propEqual due to recursion inside instances on sql(probably many-to-many bug)

- instance metadata feature:
  - index
  - reason
  - source
  - host
  - origin
  - originator_id
  - builtAt
  - [extraData]

deleteInArray / change / addInArray (should be proxied correctly when reference diff different)

# add benchmark setup
# Removing a relationship form an array
# <C-n> <C-p> to jump hunks, zo, zc
# reasons for artifacts: doc gen, code cov report, .apk builds

.. maybe add errors.has(attr) and errors.remove(attr), errors.errorsFor(attr) AND
errors.add(attr, ['', '', '']);

- Serializer interface
- push interface
- MemoryAdapter should be able to handle string id/bigint columns for increment
- ORM should allow publickey and signatures as ids

- investigate silent Errors within memoria.Server handler context
- make passthrough PASS
- add initializer.js
- rollup -i ./lib/response.js -o response.js -f cjs
- memoria glue [jsonEndpoint]

import { cast, validateLength, validateRequired, foreignKeyConstraint } from 'memoria/changeset'; // instead use class-validator
import { from } from 'memoria/query';

// MODEL API:
import Model from 'memoria/model';

class User extends Model {
  Adapter: MemoryAdapter, // or SQLAdapter, JSONAPIAdapter, JSONAdapter, GraphQLAdapter
  Serializer: ModelSerializer // or JSONSerializer, JSONAPISerializer, GraphQLSerializer

  // Extra examples: customAPIActions:
  confirm = APIAction({
    type: 'POST',
    before() {

    },
    after() {

    }
  })
}

SyncStrategies(after CommitHistory)
